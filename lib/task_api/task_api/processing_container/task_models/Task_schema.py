# generated by datamodel-codegen:
#   filename:  Task.schema.json

from __future__ import annotations

from typing import List, Optional, Union, Dict, Literal

from pydantic import BaseModel, ConfigDict

from task_api.processing_container.task_models.IOVolume_schema import IOVolume
from task_api.processing_container.task_models.TaskEnvVar import TaskEnvVar

from task_api.processing_container.pc_models import (
    TaskTemplate_schema,
    Resources_schema,
)


from kubernetes import client


class BaseConfig(BaseModel):
    labels: Optional[Dict] = {}


class DockerConfig(BaseConfig):
    type: Literal["docker"]


class K8sConfig(BaseConfig):
    type: Literal["k8s"]
    model_config = ConfigDict(arbitrary_types_allowed=True)
    namespace: Optional[str] = None
    registryUrl: Optional[str] = None
    registryUsername: Optional[str] = None
    registryPassword: Optional[str] = None
    imagePullSecrets: Optional[List[str]] = None
    env_vars: List[client.V1EnvVar] = []
    volumes: List[client.V1Volume] = []
    volume_mounts: List[client.V1VolumeMount] = []
    annotations: dict = {}


class Task(BaseModel):
    """
    Concrete usage of a TaskTemplate within a workflow.
    Captures how input/output data and parameters are bound for a particular execution.
    """

    name: str
    image: str
    taskTemplate: Union[str, TaskTemplate_schema.TaskTemplate]
    command: Optional[List[str]] = None
    inputs: List[IOVolume] = []
    outputs: List[IOVolume] = []
    env: Optional[List[TaskEnvVar]] = []
    resources: Optional[Resources_schema.Resources] = None

    config: Optional[Union[DockerConfig, K8sConfig]] = None
